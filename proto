#!/usr/bin/perl -w
use strict;
$| = 1; # flush after every print

use File::Path;
use File::Spec;
use Cwd ();

my $config_file = 'config.proto';
if ( !-e $config_file ) {
    create_default_config_file($config_file);
    my $config_info = load_config_file($config_file);
    die <<"EOMESSAGE";

*** CONFIG FILE CREATED ***

Greetings. I have created a file '$config_file' that you may want to review.
Next time you run '$0', these settings will be used to bootstrap your system
into a working Perl 6 installation.

If you're new to this, or if configuring settings scares you, you probably want
the default settings anyway. The most important ones are:
Rakudo   -> $config_info->{'Rakudo directory'}
Projects -> $config_info->{'Proto projects directory'}

EOMESSAGE
}
if ( !-r $config_file ) {
    die "The file $config_file exists but is not readable. Cannot continue.\n";
}
my ( $config_info, $commentinfo ) = load_config_file($config_file);

if ( $config_info->{'config.proto version'} lt '2009-09-23' ) {
    my $rakudo_directory = rakudo_directory( $config_info );
    my $perl6 = "$rakudo_directory/perl6";
    my $oneliner = 'use Ecosystem; sub load-config-file(Str $filename) { my %settings; for lines($filename) { when / (.*) \: \s+ (.*) / { %settings{$0} = $1 } }; return %settings }; print Ecosystem.new(load-config-file("config.proto"){"Proto projects directory"}).installed-projects().join(", ")';
    my $installed_projects = `env PERL6LIB=lib $perl6 -e '$oneliner'`;

    die <<"EOMESSAGE";

*** CONFIG FILE TOO OLD ***

Hello, faithful proto user. With its August 2009 release, Rakudo can now
install globally on the system, which means it's time for proto to install
Perl 6 modules globally too. Rather than spend a lot of effort trying to
guess how to upgrade our userbase from local to global modules, we'll just
deprecate the old ways and let you do a bit of the work. Hope it's OK!

So here's the thing: we're moving to a model where PERL6LIB only needs to
point to one lib/ dir with all the installed modules bunched together. You
should probably reinstall the projects you have already, so that they
end up in that place.

Here are your currently installed projects:

$installed_projects

When you're ready to go with the new ways, please remove your old
config.proto and reinstall the above projects.

EOMESSAGE
}

if ( ! -d $config_info->{'Proto projects directory'} ) {
    mkdir $config_info->{'Proto projects directory'}
        or die "Couldn't create projects dir";
}

# 1. perl git and subversion installed
my $git_version = qx{git --version};
my $svn_version = qx{svn --version};

# TODO: detect if either of these is missing, and install them.
$git_version =~ s/(git )version ([0-9.]+)\n/$1$2/;    # little re-format
$svn_version =~ s/^svn.*?([0-9.]+).*/subversion $1/s;   # huge re-format

my $silently = ' > /dev/null 2>&1';

install_perl6( $config_info );

my $rakudo_directory = rakudo_directory( $config_info );
my $perl6 = "$rakudo_directory/perl6";
make_pir_modules( $perl6 );
# Delegate to installer
exec( "env RAKUDO_DIR=$rakudo_directory $perl6 installer @ARGV" );

sub install_perl6 {
    my $config_info = shift;

    if (parrot_in_rakudo( $config_info ) ) {
        build_parrot_in_rakudo( $config_info );
    }
    # This call also checks that the directories are sane
    elsif (rakudo_in_parrot( $config_info )) {
        build_rakudo_in_parrot( $config_info );
    }
}

sub parrot_in_rakudo {
    my $config_info = shift;

    my $rakudo_directory = rakudo_directory($config_info);
    my $parrot_directory = parrot_directory($config_info);

    # Decide on strategy
    if ( length( $rakudo_directory ) < length( $parrot_directory ) ) {
        my $test_parrot_directory = "$rakudo_directory/parrot";
        if ( $test_parrot_directory ne $parrot_directory ) {
            die 'If you want parrot in rakudo it has to be in <RAKUDO_DIR>/parrot'
        }
        return 1;
    }
    return '';
}

sub rakudo_in_parrot {
    my $config_info = shift;

    my $rakudo_directory = rakudo_directory($config_info);
    my $parrot_directory = parrot_directory($config_info);

    if ( length( $rakudo_directory ) > length( $parrot_directory ) ) {
        my $test_rakudo_directory = "$parrot_directory/languages/rakudo";
        if ( $test_rakudo_directory ne $rakudo_directory ) {
            die 'If you want rakudo in parrot it has to be in <PARROT_DIR>/languages/rakudo';
        }
        return 1;
    }
    return '';
}

sub rakudo_directory {
    my $config_info = shift;
    my $rakudo_directory = $config_info->{'Rakudo directory'};
    my $parrot_directory = $config_info->{'Parrot directory'};

    if (   $rakudo_directory eq 'parrot-decides' 
        && $parrot_directory eq 'rakudo-decides' ) {
        die 'Either set Rakudo directory or Parrot directory in config.proto';
    }
    elsif ( $rakudo_directory eq 'parrot-decides' ) {
        $rakudo_directory = "$parrot_directory/languages/rakudo";
    }
    return $rakudo_directory;
}

sub parrot_directory {
    my $config_info = shift;
    my $rakudo_directory = $config_info->{'Rakudo directory'};
    my $parrot_directory = $config_info->{'Parrot directory'};

    if (   $rakudo_directory eq 'parrot-decides' 
        && $parrot_directory eq 'rakudo-decides' ) {
        die 'Either set Rakudo directory or Parrot directory in config.proto';
    }
    elsif ( $parrot_directory eq 'rakudo-decides' ) {
        $parrot_directory = "$rakudo_directory/parrot";
    }
    return $parrot_directory;
}

sub build_parrot_in_rakudo {
    my $config_info = shift;
    download_rakudo( $config_info );
    if ( $config_info->{'Parrot revision'} ne 'rakudo-decides' ) {
        download_parrot( $config_info );
        build_parrot( $config_info );
    }
    build_rakudo( $config_info );
}

sub build_rakudo_in_parrot {
    my $config_info = shift;
    download_parrot( $config_info );
    download_rakudo( $config_info );
    build_parrot( $config_info );
    build_rakudo( $config_info );
}

sub download_rakudo {
    my $config_info = shift;
    my $rakudo_directory = rakudo_directory( $config_info );

    # XXX Maybe check if rakudo dir has contents instead?
    return if -d $rakudo_directory;

    if ( $config_info->{'Rakudo revision'} eq 'release' ) {
        my $rakudo_release = '2009-07';
        my $tarfile = "rakudo-$rakudo_release.tar.gz";
        my $rakudo_url
            = "http://cloud.github.com/downloads/rakudo/rakudo/$tarfile";
        my $command = "wget $rakudo_url 2>&1 | "
                      . ' ./dotty-progress "Downloading Perl 6" 23';
        system( $command ) == 0 or die "\nCouldn't download Perl 6: $?";
        print "[  ok  ]\n";
        $command = "tar xzvf $tarfile 2>&1 |"
                   . ' ./dotty-progress "Unpacking Perl 6" 771';
        system( $command ) == 0 or die "\nCouldn't unpack Perl 6: $?";
        $command = "rm -f $tarfile";
        system( $command ); # Don't mind failure here
        $command = "mv rakudo-$rakudo_release $rakudo_directory $silently";
        system( $command ) == 0 or die "\nCouldn't move Perl 6: $?";
    }
    elsif ( $rakudo_directory =~ m{ (.*) / \w+ $}x ) {
        print 'Downloading Perl 6...';
        my $parent_dir = $1;
        if ( ! -d $parent_dir ) {
            mkpath($parent_dir) or die "Couldn't create $parent_dir";
        }
        if ( -d $rakudo_directory ) {
            rmtree($rakudo_directory) or die "Couldn't remove $rakudo_directory";
        }
        my $command = 'git clone git://github.com/rakudo/rakudo.git'
                      . " $rakudo_directory"
                      . $silently;
        system( $command ) == 0 or die "\nCouldn't check out Rakudo: $?";
    }
    else {
        die "Something went wrong while downloading rakudo";
    }

    print "[  ok  ]\n";
}

sub download_parrot {
    my $config_info = shift;
    my $parrot_directory = parrot_directory( $config_info );

    return if parrot_version( $parrot_directory );

    print 'Downloading Parrot...';
    my $command = 'svn checkout https://svn.parrot.org/parrot/trunk '
                  . $parrot_directory
                  . $silently;
    system( $command ) == 0 or die "\nCouldn't check out Parrot: $?";
    print "downloaded\n";
    mkpath( "$parrot_directory/languages" ) unless -d "$parrot_directory/languages";
}

sub build_rakudo {
    my $config_info = shift;
    my $rakudo_directory = rakudo_directory( $config_info );
    if ( !-f "$rakudo_directory/perl6" ) {
        # XXX Is this the correct behaviour?
        my $flags = parrot_is_built( $config_info )
                        ? ''
                        : '--gen-parrot';
        my $command
            = "(cd $rakudo_directory && perl Configure.pl $flags && make)"
              . ' 2>&1 | ./dotty-progress "Building Perl 6" 3579';
        if ( system( $command ) != 0 ) {
            print "[ FAIL ]\n";
            if ( system("grep memory make.log $silently") == 0 ) {
                die "Not enough memory to build Perl 6.\n";
            }
            die "Couldn't build Perl 6: $?";
        }
        -f "$rakudo_directory/perl6"
            or die "[ FAIL ]\nCouldn't build Perl 6.\n";
        unlink('make.log');
        print "[  ok  ]\n";
    }
}

sub build_parrot {
    my $config_info = shift;
    my $parrot_directory = parrot_directory( $config_info );

    return if parrot_is_built( $config_info );

    print 'Building parrot...';
    my $command = "(cd $parrot_directory && perl Configure.pl && make) $silently";
    system( $command ) == 0 or die "\nCouldn't build Parrot: $?";
    if ( !-x "$parrot_directory/parrot" ) {
        die "\nCouldn't build Parrot.";
    }
    print "built\n";
}

sub parrot_is_built {
    my $config_info = shift;
    my $parrot_directory = parrot_directory( $config_info );
    return 1 if -x "$parrot_directory/parrot";
    return '';
}

sub parrot_version {
    my ($parrot_dir) = @_;

    my $parrot_readme = "$parrot_dir/README";
    if ( -f $parrot_readme ) {
        open my $handle, '<', $parrot_readme or return;
        if ( defined( my $line = <$handle> ) ) {
            if ( $line =~ /^This is Parrot, version ([0-9.]+)/ ) {
                return $1;
            }
        }
    }
    return;
}

sub make_pir_modules {
    my ($perl6) = @_;
    my $displayed_building = 0;
    # Precompile these modules to PIR
    for my $name ( 'Ecosystem', 'Installer' ) {
        if ( ! -f "lib/$name.pir" || -M "lib/$name.pir" > -M "lib/$name.pm") {
            unless ( $displayed_building ) {
                print "Building proto..."; $displayed_building = 1;
            }
            system( "env -i PERL6LIB=`pwd`/lib $perl6 --target=pir --output=lib/$name.pir lib/$name.pm" );
        }
    }
    if ( $displayed_building ) {
        print "done\n";
    }
}

sub create_default_config_file {
    my ($file_name) = @_;

    my  $commentinfo = {
        '/' => [ 'config.proto -- created by proto',
                 'The file consists of a number of settings written as',
                 'key/value pairs. You are welcome -- encouraged, even -- to',
                 'edit the file manually, but please stick to a list of',
                 'key/value pairs.' ],
        'config.proto version'
            => [ 'config.proto version -- the version number of this file.',
                 'proto uses it to determine whether the file needs to be',
                 'upgraded to a newer version. The value should never need',
                 'to be edited manually.' ],
        'Proto projects directory'
            => [ 'Proto projects directory -- the path to a directory, which',
                 'may or may not exist, which will contain the projects',
                 'downloaded by proto, including (if needed) Parrot and',
                 'Perl 6. If you set this to a different path after projects',
                 'have already been installed, be aware that the old projects',
                 'will have to be moved along if proto is to find them' ],
        'Parrot directory'
            => [ 'Parrot directory -- the path to the directory, which may',
                 'or may not exist, where Parrot lives or will be installed.',
                 'When the value of "Rakudo setup" is set to "Rakudo',
                 'outermost", the value of this setting won\'t matter',
                 'because Rakudo will decide which Parrot version to',
                 'download.' ],
        # TODO: Implement downloading of specific releases.
        'Parrot revision'
            => [ 'Parrot revision -- the revision of Parrot to download, if',
                 'no Parrot was found in $PARROT_DIR at startup. Allowed',
                 'values are "release", "bleeding", and an integer (optionally',
                 'preceded by the letter "r"). The value "bleeding" means to',
                 'download the latest Parrot revision from SVN, whereas',
                 '"release" means to download the latest release as a',
                 'tarball. When the value of "Rakudo setup" is set to',
                 '"Rakudo outermost", the value of this setting won\'t matter',
                 'because Rakudo will decide which Parrot version to',
                 'download.' ],
        'Rakudo directory'
            => [ 'Rakudo directory -- the path to the directory, which may',
                 'or may not exist, where Rakudo lives or will be installed.'
               ],
        # TODO: Implement downloading of specific releases.
        'Rakudo revision'
            => [ 'Rakudo revision -- the revision of Rakudo Perl 6 to',
                 'download, if no such revision was found in $RAKUDO_DIR or',
                 'other likely locations at startup. Allowed values are',
                 '"release", "bleeding", and a hexadecimal integer of length',
                 'up to 40. The value "bleeding" means to download the latest',
                 'Rakudo Perl 6 revision from github, whereas "release" means',
                 'to download the latest release as a tarball.' ],
        'Test when building'
            => [ 'Test when building -- when building projects that were just',
                 'downloaded or updated, whether to also run the test suites',
                 'of those projects. This option only controls whether the',
                 'tests are actually run; the "Test failure policy"',
                 'determines whether or not to halt the build process on',
                 'a failing test suite. Values other than "yes" are treated',
                 'as "no".' ],
        'Test failure policy'
            => [ 'Test failure policy -- what to do when tests fail in the',
                 'test suites of projects that are being installed. Note that',
                 'this option has no effect unless the option "Test when',
                 'building" has been set to "yes". The value "die" of this',
                 'option means that the build process halts whenever a test',
                 'suite fails. Other values are treated as "keep going".' ],
        'Perl 6 project developer'
            => [ 'Perl 6 project developer -- when set, this option makes',
                 'proto try to download read-write versions of project',
                 'repositories, from which project development can be',
                 'carried out. If such a download fails, proto falls back to',
                 'downloading the project the usual way.' ],
    };
    my $parrot_dir = $ENV{'PARROT_DIR'}; # often undef
    my $rakudo_dir = $ENV{'RAKUDO_DIR'}; # often undef
    my $projects_dir = Cwd::abs_path( File::Spec->updir() );

    my $config_info = {
        'config.proto version' => '2009-03-17',
        'Proto projects directory' => $projects_dir,
        'Test when building' => 'no',
        'Test failure policy' => 'die',
        'Perl 6 project developer' => 'no',
    };

    if ( !defined $parrot_dir && defined $rakudo_dir ) {
        # derive the parrot_dir from rakudo_dir: there are only 2 possibilities
        if ( $rakudo_dir =~ m{(.*)/languages/rakudo$} ) {
            # Parrot contains Rakudo
            $parrot_dir = $1;
            #$config_info->{'Rakudo setup'} = 'Parrot outermost';
        }
        else {
            # rakudo contains parrot
            $parrot_dir = $rakudo_dir . '/parrot';
            #$config_info->{'Rakudo setup'} = 'Rakudo outermost';
        }
    }
    if ( !defined $rakudo_dir ) {
        #$config_info->{'Rakudo setup'} = 'Rakudo outermost';
        $config_info->{'Rakudo revision'} = 'bleeding',
        $config_info->{'Parrot revision'} = 'rakudo-decides',
        $rakudo_dir = "$projects_dir/rakudo";
    }
    if ( !defined $parrot_dir ) {
        $parrot_dir = 'rakudo-decides';
    }
    if ( $parrot_dir and $rakudo_dir ) {
        $config_info->{'Parrot revision'} = 'rakudo-decides',
    }

    $config_info->{'Parrot directory'} = $parrot_dir;
    $config_info->{'Rakudo directory'} = $rakudo_dir;

    save_config_file($file_name, $config_info, $commentinfo )
        or die "Couldn't create $file_name: $!\n";
}

sub load_config_file {
    my ( $filename ) = @_;
    my $settings = {};
    my $comments = {};
    my @collected_comments = ();
    open my $YAML_FILE, '<', $filename
        or die "cannot open $filename for read: $!";
    my $doc_sep_line = qr/^---/;
    my $comment_line = qr/\#(.*)$/;
    my $setting_line = qr/(.*):\s+(.*)/;
    while ( my $line = <$YAML_FILE> ) {
        chomp $line;
        if ( $line =~ $doc_sep_line ) {
            $comments->{'/'} = [ @collected_comments ];
            @collected_comments = ();
        }
        elsif ( $line =~ $comment_line ) {
            push @collected_comments, $1;
        }
        elsif ( $line =~ $setting_line ) {
            $settings->{$1} = $2;
            $comments->{$1} = [ @collected_comments ];
            @collected_comments = ();
        }
    }
    close $YAML_FILE;
    return wantarray ? ( $settings, $comments ) : $settings;
}

sub save_config_file {
    my ( $filename, $settings, $comments ) = @_;
    if ( not defined $comments ) { $comments = { }; }
    open my $YAML_FILE, '>', $filename
        or die "cannot open $filename for write: $!";
    my $main_comments = $comments->{'/'};
    if ( defined $main_comments ) {
        for my $comment ( @$main_comments ) {
            print {$YAML_FILE} "# $comment\n";
        }
    }
    print {$YAML_FILE} "--- \n";
    for my $settingname ( sort keys %$settings ) {
        print {$YAML_FILE} "\n";
        my $setting_comments = $comments->{$settingname};
        if ( defined $setting_comments ) {
            for my $comment ( @$setting_comments ) {
                print {$YAML_FILE} "# $comment\n";
             }
        }
        print {$YAML_FILE} "$settingname: ", ${$settings}{$settingname}, "\n";
    }
    close $YAML_FILE;
}

=pod

=head1 NAME

proto - downloader and builder for Parrot and Rakudo

=head1 ENVIRONMENT

PARROT_DIR - if exported by the shell, specifies where to look for an installed
Parrot directory.

RAKUDO_DIR - if exported by the shell, specifies where to look for an installed
Rakudo directory.

If both variables are defined, the directories must be nested as either
parrot/languages/rakudo or rakudo/parrot.

=head1 TODO

The installed-modules branch plans to make proto more PERL6LIB-friendly by
doing the following:

1.  Place all installed Perl 6 modules (.pm and .pir files) into one
    folder hierarchy, so that PERL6LIB does not grow with installs.
    To support this, add a new "Ecosystem directory" setting to
    config.proto, with $HOME/.ecosystem as default value.
    (Q: how about names "Perl 6 library" and .perl6lib instead?)

2.  Rename the current "install" proto subcommand to "fetch". Add a new
    "install" step to the end of the existing "fetch, configure, build,
    test" workflow.

3.  Keep a separate cache directory per project for all processing prior
    to installation. Allow the cache directory to be cleaned or removed
    without affecting the installed module.

4.  It may not have to be a sudden reinstall of all projects. We could
    add a "Proto cache directory" alongside the "Proto projects directory"
    at some stage and favour it for updates and new projects. Each
    project added to "Proto cache" can be removed from "Proto projects".
    At a later stage the "Proto projects directory" can be phased out.

5.  Detect and use a 'make install' target if found, otherwise do the
    right thing based on a lib/ directory and filename extensions.
    Similarly try to perform update and uninstall operations.

6.  Update create-new-project to support 'make install', update and
    uninstall. Document it as a guideline for module developers.

7.  ...

=cut
