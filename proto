#!/usr/bin/perl -w
use strict;
$| = 1; # flush after every print

use File::Path;
use File::Spec;
use Cwd qw(abs_path);

my ($volume,$proto_dir,$file) = File::Spec->splitpath(abs_path($0));
my $config_file = File::Spec->catpath( $volume, $proto_dir,'config.proto');
my $state_file = File::Spec->catpath( $volume, $proto_dir,'projects.state');
if ( ! -e $config_file ) {
    create_default_config_file($config_file);
    my $config_info = load_config_file($config_file);
    die <<"EOMESSAGE";

*** CONFIG FILE CREATED ***

Greetings! I have created a file '$config_file'
that you may want to review. Next time you run $0
these settings will be used to bootstrap your Perl 6 software ecosystem.

If you're new to this, or reluctant to do configuration, you probably want
the default settings anyway. The most important ones are:
Perl 6 executable -> $config_info->{'Perl 6 executable'}
Perl 6 library    -> $config_info->{'Perl 6 library'}

EOMESSAGE
}
if ( ! -r $config_file ) {
    die "The file $config_file exists but is not readable. Cannot continue.\n";
}

my ( $config_info, $commentinfo ) = load_config_file($config_file);

if ( $config_info->{'config.proto version'} lt '2009-09-23' ) {
    my @legacy_projects = legacy_projects( $config_info );
    create_default_state_file( $state_file, @legacy_projects );
    die <<"EOMESSAGE";

*** CONFIG FILE TOO OLD ***

Hello, faithful proto user. Since the August 2009 release, Rakudo installs
and runs outside its source directories. It's time for proto to make projects
install Perl 6 projects in a similar way. Rather than spend a lot of effort
trying to guess how to upgrade our userbase from distributed to merged, we'll
just deprecate the old ways and let you do a bit of the work. Hope it's OK!

So here's the thing: we're moving to a model where PERL6LIB becomes optional
or needs to point to only one library base directory. You should probably
reinstall the projects you have already, so that they end up in that place.

Here are your currently installed projects ('legacy' in projects.state):

@legacy_projects

When you're ready to go with the new ways, please remove your old
config.proto and reinstall the above projects.

EOMESSAGE
}

if ( ! -d $config_info->{'Perl 6 library'} ) {
    mkpath $config_info->{'Perl 6 library'}
        or die "Couldn't create Perl 6 library dir";
}
if ( ! -d $config_info->{'Proto projects cache'} ) {
    mkpath $config_info->{'Proto projects cache'}
        or die "Couldn't create Proto projects cache dir";
}
if ( ! -f $state_file ) {
    create_default_state_file( $state_file );
}

# 1. perl git and subversion installed
my $git_version = qx{git --version};
my $svn_version = qx{svn --version};

# TODO: detect if either of these is missing, and install them.
$git_version =~ s/(git )version ([0-9.]+)\n/$1$2/;    # little re-format
$svn_version =~ s/^svn.*?([0-9.]+).*/subversion $1/s;   # huge re-format

my $silently = ' > /dev/null 2>&1';

my $perl6 = $config_info->{'Perl 6 executable'};
#if ( system("$perl6 -v $silently") != 0 ) {
    install_perl6( $config_info );
#}
make_pir_modules( $perl6 );
exec( "$perl6 installer @ARGV" ); # Delegate to installer


sub install_perl6 {
    my $config_info = shift;
    my $perl6 = $config_info->{'Perl 6 executable'};
    my $rakudo_directory;
    if ( $perl6 =~ m{ (.*) /parrot_install/bin/perl6 }x ) {
        $rakudo_directory = $1;
    }
    elsif ( $perl6 =~ m{ (.*) /perl6 }x ) {
        $rakudo_directory = $1;
    }
    else {
        die "cannot figure Rakudo directory from $perl6";
    }
    download_rakudo( $config_info, $rakudo_directory );
    build_rakudo( $config_info, $rakudo_directory );
}

sub download_rakudo {
    my ( $config_info, $rakudo_directory ) = @_;
    # XXX Maybe check if rakudo dir has contents instead?
    return if -d $rakudo_directory;

    if ( $config_info->{'Rakudo revision'} eq 'release' ) {
        my $rakudo_release = '2009-08';
        my $tarfile = "rakudo-$rakudo_release.tar.gz";
        my $rakudo_url
            = "http://cloud.github.com/downloads/rakudo/rakudo/$tarfile";
        my $command = "wget $rakudo_url 2>&1 | "
                      . ' ./dotty-progress "Downloading Perl 6" 23';
        system( $command ) == 0 or die "\nCouldn't download Perl 6: $?";
        print "[  ok  ]\n";
        $command = "tar xzvf $tarfile 2>&1 |"
                   . ' ./dotty-progress "Unpacking Perl 6" 771';
        system( $command ) == 0 or die "\nCouldn't unpack Perl 6: $?";
        $command = "rm -f $tarfile";
        system( $command ); # Don't mind failure here
        $command = "mv rakudo-$rakudo_release $rakudo_directory $silently";
        system( $command ) == 0 or die "\nCouldn't move Perl 6: $?";
    }
    elsif ( $rakudo_directory =~ m{ (.*) / \w+ $}x ) {
        print 'Downloading Perl 6...';
        my $parent_dir = $1;
        if ( ! -d $parent_dir ) {
            mkpath($parent_dir) or die "Couldn't create $parent_dir";
        }
        if ( -d $rakudo_directory ) {
            rmtree($rakudo_directory) or die "Couldn't remove $rakudo_directory";
        }
        my $command = 'git clone git://github.com/rakudo/rakudo.git'
                      . " $rakudo_directory"
                      . $silently;
        system( $command ) == 0 or die "\nCouldn't check out Rakudo: $?";
    }
    else {
        die "Something went wrong while downloading rakudo";
    }

    print "[  ok  ]\n";
}

sub build_rakudo {
    my ( $config_info, $rakudo_directory ) = @_;
    if ( ! -f "$rakudo_directory/perl6" ) {
        my $flags = '--gen-parrot';
        my $command
            = "(cd $rakudo_directory && perl Configure.pl $flags && make install)"
              . ' 2>&1 | ./dotty-progress "Building Perl 6" 4258'; # TODO: recalibrate
        if ( system($command) != 0 ) {
            print "[ FAIL ]\n";
            if ( system("grep memory make.log $silently") == 0 ) {
                die "Not enough memory to build Perl 6.\n";
            }
            die "Couldn't build Perl 6: $?";
        }
        -f "$rakudo_directory/perl6"
            or die "[ FAIL ]\nCouldn't build Perl 6.\n";
        unlink('make.log');
        print "[  ok  ]\n";
    }
}

sub make_pir_modules {
    my ($perl6) = @_;
    my $displayed_building = 0;
    # Precompile these modules to PIR
    for my $name ( 'Ecosystem', 'Installer' ) {
        if ( ! -f "lib/$name.pir" || -M "lib/$name.pir" > -M "lib/$name.pm" || -M "lib/$name.pir" > -M $perl6 ) {
            unless ( $displayed_building ) {
                print "Building proto..."; $displayed_building = 1;
            }
            system( "env -i PERL6LIB=`pwd`/lib $perl6 --target=pir --output=lib/$name.pir lib/$name.pm" );
        }
    }
    if ( $displayed_building ) {
        print "done\n";
    }
}

sub legacy_projects {
    my ( $config_info ) = @_;
    my @legacy_projects;
    my $project_dir = $config_info->{'Proto projects directory'};
    open PROJECTS_LIST, '<', 'projects.list' or die "cannot open projects list";
    while ( defined( my $line = <PROJECTS_LIST> ) ) {
        if ( $line =~ m/ ^ (\S+) : $ /x ) {
            my $project = $1;
            if ( -d "$project_dir/$project" and $project ne 'proto' ) {
                push @legacy_projects, $project;
            }
        }
    }
    close PROJECTS_LIST;
    return @legacy_projects;
}

sub create_default_config_file {
    my ($file_name) = @_;

    my  $commentinfo = {
        '/' => [ 'config.proto -- created by proto',
                 'The file consists of a number of settings written as',
                 'key/value pairs. You are welcome -- encouraged, even -- to',
                 'edit the file manually, but please stick to a list of',
                 'key/value pairs.' ],
        'config.proto version'
            => [ 'config.proto version -- the version number of this file.',
                 'proto uses it to determine whether the file needs to be',
                 'upgraded to a newer version. The value should never need',
                 'to be edited manually.' ],
        'Proto projects cache'
            => [ 'Proto projects cache -- the base directory in which each project',
                 'gets its own download directory' ],
        'Perl 6 executable'
            => [ 'Perl 6 executable -- how to run perl6. ' ],
        'Perl 6 library'
            => [ 'Perl 6 library -- the path to a directory, which will be created',
                 'if it does not exist, which will contain the projects installed',
                 'by proto. If you set this to a different path after projects',
                 'have already been installed, be aware that the old projects',
                 'will have to be moved along if proto is to find them' ],
        # TODO: Implement downloading of specific releases.
        'Rakudo revision'
            => [ 'Rakudo revision -- the revision of Rakudo Perl 6 to',
                 'download, if no such revision was found in $RAKUDO_DIR or',
                 'other likely locations at startup. Allowed values are',
                 '"bleeding", "release", and a hexadecimal integer of length',
                 'up to 40. The value "bleeding" means to download the latest',
                 'Rakudo Perl 6 revision from github, whereas "release" means',
                 'to download the latest release as a tarball.' ],
        'Test when building'
            => [ 'Test when building -- when building projects that were just',
                 'downloaded or updated, whether to also run the test suites',
                 'of those projects. This option only controls whether the',
                 'tests are actually run; the "Test failure policy"',
                 'determines whether or not to halt the build process on',
                 'a failing test suite. Values other than "yes" are treated',
                 'as "no".' ],
        'Test failure policy'
            => [ 'Test failure policy -- what to do when tests fail in the',
                 'test suites of projects that are being installed. Note that',
                 'this option has no effect unless the option "Test when',
                 'building" has been set to "yes". The value "die" of this',
                 'option means that the build process halts whenever a test',
                 'suite fails. Other values are treated as "keep going".' ],
        'Perl 6 project developer'
            => [ 'Perl 6 project developer -- when set, this option makes',
                 'proto try to download read-write versions of project',
                 'repositories, from which project development can be',
                 'carried out. If such a download fails, proto falls back to',
                 'downloading the project the usual way.' ],
    };
    my $cache_dir  = File::Spec->rel2abs('.') . '/cache';
    my $perl6lib = $ENV{'HOME'} . '/.perl6lib';
    my $perl6exe;
    if ( exists( $ENV{PERL6EXE} ) ) { # if you know what you're doing
        $perl6exe = $ENV{PERL6EXE};
    }
    else { # default: install rakudo in the same directory as proto
        my $path = File::Spec->rel2abs($0);
        my ($volume,$directories,$file) = File::Spec->splitpath( $path );
        my @dirs = File::Spec->splitdir( $directories );
        pop @dirs if ( $dirs[$#dirs] eq '' ); # remove silly empty value
#       print "DIR: $directories\n";
#       for ( my $i=0; $i <= $#dirs; $i++ ) {
#           print "DIR[$i]: $dirs[$i]\n";
#       }
        $dirs[$#dirs] = 'rakudo';
        push @dirs, 'parrot_install', 'bin';
        $directories = File::Spec->catdir( @dirs );
        $perl6exe = File::Spec->catpath( $volume, $directories, 'perl6' );
#        $perl6exe = $ENV{'HOME'} . '/rakudo/parrot_install/bin/perl6';
    }

    my $config_info = {
        'config.proto version' => '2009-09-23',
        'Proto projects cache' => $cache_dir,
        'Perl 6 executable' => $perl6exe,
        'Perl 6 library' => $perl6lib,
        'Rakudo revision' => 'bleeding',
        'Test when building' => 'no',
        'Test failure policy' => 'die',
        'Perl 6 project developer' => 'no',
    };
    save_config_file($file_name, $config_info, $commentinfo )
        or die "Couldn't create $file_name: $!\n";
}

sub create_default_state_file {
    my ($file_name, @projectnames ) = @_;
    open PROJECTS_STATE, ">", $file_name or die "cannot create $file_name: $!";
    for my $projectname (@projectnames) {
        print PROJECTS_STATE "$projectname:\n    state: legacy\n\n";
    }
    close PROJECTS_STATE;
}

sub load_config_file {
    my ( $filename ) = @_;
    my $settings = {};
    my $comments = {};
    my @collected_comments = ();
    open my $YAML_FILE, '<', $filename
        or die "cannot open $filename for read: $!";
    my $doc_sep_line = qr/^---/;
    my $comment_line = qr/\#(.*)$/;
    my $setting_line = qr/(.*):\s+(.*)/;
    while ( my $line = <$YAML_FILE> ) {
        chomp $line;
        if ( $line =~ $doc_sep_line ) {
            $comments->{'/'} = [ @collected_comments ];
            @collected_comments = ();
        }
        elsif ( $line =~ $comment_line ) {
            push @collected_comments, $1;
        }
        elsif ( $line =~ $setting_line ) {
            $settings->{$1} = $2;
            $comments->{$1} = [ @collected_comments ];
            @collected_comments = ();
        }
    }
    close $YAML_FILE;
    return wantarray ? ( $settings, $comments ) : $settings;
}

sub save_config_file {
    my ( $filename, $settings, $comments ) = @_;
    if ( not defined $comments ) { $comments = { }; }
    open my $YAML_FILE, '>', $filename
        or die "cannot open $filename for write: $!";
    my $main_comments = $comments->{'/'};
    if ( defined $main_comments ) {
        for my $comment ( @$main_comments ) {
            print {$YAML_FILE} "# $comment\n";
        }
    }
    print {$YAML_FILE} "--- \n";
    for my $settingname ( sort keys %$settings ) {
        print {$YAML_FILE} "\n";
        my $setting_comments = $comments->{$settingname};
        if ( defined $setting_comments ) {
            for my $comment ( @$setting_comments ) {
                print {$YAML_FILE} "# $comment\n";
            }
        }
        print {$YAML_FILE} "$settingname: ", ${$settings}{$settingname}, "\n";
    }
    close $YAML_FILE;
}

__DATA__

=pod

=head1 NAME

proto - download and install Parrot, Rakudo, and Perl 6 projects

=head1 OVERVIEW

The C<proto> command is a Perl 5 script that installs Rakudo Perl 6 and Parrot
if they are not already installed. It then hands over to the Perl 6
C<Installer> script to download, test and install your choice of Perl 6
projects.

The C<Installer> script

=head1 ENVIRONMENT

PERL6EXE - if exported by the shell, specifies where to look for an installed
Perl 6 executable. Not required if your shell executes 'perl6' anyway.
The setting is saved as 'Perl 6 executable' in config.proto.
It is configured automatically if you let proto install Rakudo (and Parrot).
For example, to use perl6.pbc instead of the fakecutable use something like:

    PERL6EXE=/my/parrot_install/bin/parrot \
        /my/parrot_install/lib/<version>/languages/perl6/perl6.pbc \
        ./proto

=head1 TODO

The installed-modules branch plans to improve proto by doing the following:

1.  Place all installed Perl 6 modules (.pm and .pir files) into one
    folder hierarchy. Rakudo now preloads @*INC with $HOME/.perl6lib,
    followed by <parrot_install>/lib/<version/languages/perl6/lib, the
    directories in PERL6LIB, and lastly '.' (the current directory).
    Add a "Perl 6 library" setting to config.proto, with $HOME/.perl6lib
    as default value. (This may become $HOME/.perl6/lib).
    [DONE]

2.  Keep a separate cache directory per project for all processing prior
    to installation. Allow the cache directory to be cleaned or removed
    without affecting the installed module.
    Add a "Proto cache directory" to config.proto with a default value
    of <proto_base>/cache.
    [DONE]

3.  Add a projects.state file to register installed projects.
    The format of projects.state is similar to projects.list, currently
    with a C<state> field whose value may be 'legacy', 'built', 'tested'
    (meaning passed *all* tests in the cache directory) or 'installed'.
    Route all access to projects.state information via the Ecosystem class.
    [DONE]

4.  Rename the existing "fetch" submethod to "download", "install" ->
    "fetch", "update" -> "refresh" and "uninstall" -> "clean".
    Rename Ecosystem::is-installed() to Ecosystem::is_fetched().
    [DONE]

5.  Factor out the code common in the existing "install" and "update"
    methods, or unify them and add a new/existing flag. Either way, stop
    the repetition because we need to edit this part significantly.
    [DONE]

6.  Replace the 'Parrot directory' and 'Rakudo directory' settings with
    'Perl 6 executable' in config.proto.
    [DONE]

7.  Make install_perl6 implement L<http://www.rakudo.org/how-to-get-rakudo>,
    including the new 'make install' step.
    [DONE]

8.  Use the shiny new %*ENV for passing environment variables to child
    processes.
    [DONE]

9.  Add a new "install" step to the end of the existing "fetch,
    configure, build, test" workflow, to copy module files to the
    "Perl 6 library" tree.
    To install modules into the global library tree, first look for an
    an 'install' target in the Makefile, run it if found.
    If there is no 'install', check that all the files in lib/ can be
    copied without clobbering, then either proceed to copy or abort.
    [PART DONE]

10. Add a new "update" command that works like the new "install" for the
    latest version of a project if a previous version was installed.
    Handle 'update' like 'install' but allow files to be overwritten.
    Use the 'install' target in the Makefile, not 'update'.

11. Handle 'uninstall' by Makefile or by listing all the names in
    $project/lib and deleting each same named file in "Perl 6 library".
    Also remove the project name from projects.installed and delete the
    project cache directory. Think "realclean".
    We could keep the cache, but a "rm -rf" and a new fetch is cleaner.

12. Ensure robustness of the workflow, so that an error in fetching,
    building or testing any dependency, stops the dependent module
    being installed. Refactor the existing code to do this very
    concisely in the top level methods.

13. Drop the migration plan for existing installations: laziness++ ;)
    Just make a warning list of apparently non updated projects.

14. Validate @*INC by exiting with a friendly explanation if @*INC does
    not contain the 'Perl 6 library' directory. List the possible fixes:
    edit config.proto (set Perl 6 library), or any one of
    ~/.bash_profile, ~/.bash_login, or ~/.profile (set PERL6LIB).
    Make this behaviour optional with a 'Validate Perl 6 library' option
    in config.proto.

15. Update create-new-project to support install, update and uninstall
    in its Makefile. Document it as a guideline for module developers.

16. ...keep planning and doing...

=cut
