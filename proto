#!/usr/bin/perl -w
use strict;
$| = 1; # flush after every print

use Archive::Tar;
use Archive::Extract;
use Cwd qw(abs_path);
use File::HomeDir;
use File::Path;
use File::Spec;
use LWP::UserAgent;

#---------------------------- main program -----------------------------
# The old proto used to keep its data local, the new one is global.
my ( $home_vol, $home_dir ) = File::Spec->splitpath(
    File::HomeDir->my_home, 1 );
my $perl6basedir = File::Spec->catpath( $home_vol, $home_dir, '.perl6' );
my $config_file = File::Spec->catfile( $perl6basedir, 'proto', 'proto.conf' );
my $state_file =  File::Spec->catfile( $perl6basedir, 'lib', 'projects.state' );
if ( ! -e $config_file ) {
    create_default_config_file($config_file);
    my $config_info = load_config_file($config_file);
    die <<"PROTO_CONFIG_MESSAGE";

*** CONFIG FILE CREATED ***

Greetings! I have created a file '$config_file'
that you may want to review. Next time you run $0
these settings will be used to bootstrap your Perl 6 software ecosystem.

If you're new to this, or reluctant to do configuration, you probably want
the default settings anyway. The most important ones are:
Perl 6 executable      -> $config_info->{'Perl 6 executable'}
Perl 6 library         -> $config_info->{'Perl 6 library'}

PROTO_CONFIG_MESSAGE
}

# So, continue here if there was an existing config.proto file
if ( ! -r $config_file ) {
    die "The file $config_file exists but is not readable. Cannot continue.\n";
}

my ( $config_info, $commentinfo ) = load_config_file($config_file);

# Create all the directories that do not yet exist
for my $path (
    $config_info->{'Perl 6 library'},
    $config_info->{'Parrot build directory'},
    $config_info->{'Rakudo build directory'},
    $config_info->{'Proto projects cache'}
) {
    unless ( -d $path ) {
        File::Path->make_path( $path )
            or die "Cannot create directory $path";
    }
}
create_default_state_file( $state_file ) unless ( -f $state_file );

# 1. perl git and subversion installed
my $git_version = qx{git --version};
my $svn_version = qx{svn --version};

# TODO: detect if either of these is missing, and install them.
$git_version =~ s/(git )version ([0-9.]+)\n/$1$2/;    # little re-format
$svn_version =~ s/^svn.*?([0-9.]+).*/subversion $1/s;   # huge re-format

my $silently = ' > /dev/null 2>&1';

my $perl6 = $config_info->{'Perl 6 executable'};
#if ( system("$perl6 -v $silently") != 0 ) {
unless ( -x $perl6 ) {
    install_perl6( $config_info );
}
make_pir_modules( $perl6, $config_info->{'Perl 6 library'} );
exec( "$perl6 installer @ARGV" ); # Delegate to installer

#---------------------------- install_perl6 ----------------------------
sub install_perl6 {
    my ($config_info) = @_;
    download_parrot( $config_info );
    build_parrot(    $config_info );
    download_rakudo( $config_info );
    build_rakudo(    $config_info );
}

#--------------------------- download_parrot ---------------------------
sub download_parrot {
    my ($config_info) = @_;
    my $parrot_build_dir = $config_info->{'Parrot build directory'};
    if ( $config_info->{'Parrot version'} =~ m/\d+\.\d+\.\d+/x ) {
        print "proto is downloading a Parrot tarball...";
        # a tested release
        my $parrot_version = $config_info->{'Parrot version'};
        my $parrot_tarfile = "parrot-$parrot_version.tar.gz";
        my $ua = LWP::UserAgent -> new;
        $ua->show_progress( 1 );
        my $url = "http://ftp.parrot.org/releases/devel/$parrot_version/$parrot_tarfile";
        my $filename = File::Spec->catfile(
            $config_info->{'Parrot build directory'},
            $parrot_tarfile
        );
        print "filename = $filename\n";
        $ua->mirror( $url, $filename );
        # Archive::Tar
        my $ae = Archive::Extract->new( archive => $filename );
        $ae->extract( to => $config_info->{'Parrot build directory'} )
            or die "cannot extract from archive";
    }
    elsif ( $config_info->{'Parrot version'} =~ m/ ^ \d{5,6} $ /x ) {
        # use Subversion to checkout a Parrot revision such as 41208
        print "proto is checking out a Parrot revision...";
    }
    elsif ( $config_info->{'Parrot version'} eq 'trunk' ) {
        print "proto is checking out Parrot trunk...";
        my $command = "svn checkout https://svn.parrot.org/parrot/trunk $parrot_build_dir";
        print "command = $command";
        system( $command );
    }
    else {
        die "The Parrot version is $config_info->{'Rakudo revision'}" .
            " but should be 'trunk' or a number such as '2.2.0'";
    }
    print "parrot download done\n";
}

#---------------------------- build_parrot -----------------------------
sub build_parrot {
    my ($config_info) = @_;
    my $cwd = Cwd->getcwd();
    my $parrot_build_dir;
    print "proto is building Parrot...";
    if ( $config_info->{'Parrot version'} =~ m/\d+\.\d+\.\d+/x ) {
        $parrot_build_dir = File::Spec->catdir( 
            $config_info->{'Parrot build directory'},
            'parrot-' . $config_info->{'Parrot version'}
        );
    }
    elsif ( $config_info->{'Parrot version'} =~ m/ ^ \d{5,6} $ /x ) {
        $parrot_build_dir = $config_info->{'Parrot build directory'};
    }
    elsif ( $config_info->{'Parrot version'} eq 'trunk' ) {
        $parrot_build_dir = $config_info->{'Parrot build directory'};
    }
    else {
        die "The Parrot version is $config_info->{'Rakudo revision'}" .
            " but should be 'trunk' or a number such as '2.2.0'";
    }
        chdir $parrot_build_dir or die "cannot chdir";
        my $version = $config_info->{'Parrot version'};
        my $prefix  = $config_info->{'Parrot install directory'};
        my @parrot_options = (
            "--prefix=$prefix",
            "--optimize"              # does this work on Windows?
        );
        my $command = "$^X Configure.pl @parrot_options";
        # run Parrot's Configure.pl
        print "command = $command\n";
        system( $command );
        # run Parrot's make
        $command = "make install";
        system( $command );
    chdir $cwd;
    print "building Parrot done\n";
}

#--------------------------- download_rakudo ---------------------------
sub download_rakudo {
    my ( $config_info ) = @_;
    my $rakudo_build_dir = $config_info->{'Rakudo build directory'};
    print "proto is downloading Rakudo...";
    # XXX Maybe check if rakudo dir has contents instead?
#    return if -d $rakudo_build_dir;

    if ( $config_info->{'Rakudo version'} =~ m/ \d{4}\.\d{2} /x ) {
        my $rakudo_version = $config_info->{'Rakudo version'};
        my $rakudo_release_tarfile = "rakudo-$rakudo_version.tar.gz";
        my $ua = LWP::UserAgent -> new;
        $ua->show_progress( 1 );
        my $url = "http://cloud.github.com/downloads/rakudo/rakudo/$rakudo_release_tarfile";
        my $filename = File::Spec->catfile(
            $config_info->{'Rakudo build directory'},
            $rakudo_release_tarfile
        );
        print "filename = $filename\n";
        $ua->mirror( $url, $filename );
        my $ae = Archive::Extract->new( archive => $filename );
        $ae->extract( to => $config_info->{'Rakudo build directory'} )
            or die "cannot extract from archive";

=pod

        my $rakudo_release = '2010.02';
        my $tarfile = "rakudo-$rakudo_release.tar.gz";
        my $rakudo_url
            = "http://cloud.github.com/downloads/rakudo/rakudo/$tarfile";
        # TODO: perform the download with Perl 5 and LWP instead
        my $command = "wget $rakudo_url 2>&1 | "
                      . ' ./dotty-progress "Downloading Perl 6" 23';
        system( $command ) == 0 or die "\nCouldn't download Perl 6: $?";
        print "[  ok  ]\n";
        $command = "tar xzvf $tarfile 2>&1 |"
                   . ' ./dotty-progress "Unpacking Perl 6" 771';
        system( $command ) == 0 or die "\nCouldn't unpack Perl 6: $?";
        $command = "rm -f $tarfile";
        system( $command ); # Don't mind failure here
        $command = "mv rakudo-$rakudo_release $rakudo_build_dir $silently";
        system( $command ) == 0 or die "\nCouldn't move Perl 6: $?";

=cut

    }
    elsif ($config_info->{'Rakudo version'} eq 'bleeding') {
        my $command = 'git clone git://github.com/rakudo/rakudo.git '.
            $config_info->{'Rakudo build directory'};
        print "\ncommand = $command\n";
        if ( system( $command ) != 0 ) {
            die "Downloading Rakudo using git clone failed";
        }

=pod

        if ( $rakudo_build_dir =~ m{ (.*) / \w+ $}x ) {
            print 'Downloading Rakudo Perl 6...';
            my $parent_dir = $1;
            if ( ! -d $parent_dir ) {
                mkpath($parent_dir) or die "Couldn't create $parent_dir";
            }
            if ( -d $rakudo_build_dir ) {
                rmtree($rakudo_build_dir) or die "Couldn't remove $rakudo_build_dir";
            }
            my $command = 'git clone git://github.com/rakudo/rakudo.git'
                      . " $rakudo_build_dir"
                      . $silently;
            system( $command ) == 0 or die "\nCouldn't check out Rakudo: $?";
        }
        else {
            die "Something went wrong while downloading rakudo";
        }

=cut

    }
    else {
        die "Rakudo version was neither 'bleeding' nor a number like '2010.02'";
    }

    print "[ Rakudo download ok  ]\n";
}

#---------------------------- build_rakudo -----------------------------
sub build_rakudo {
    my ($config_info) = @_;
    my $rakudo_build_dir;
    if ( $config_info->{'Rakudo version'} =~ m/ \d{4}\.\d{2} /x ) {
        $rakudo_build_dir = File::Spec->catdir(
            $config_info->{'Rakudo build directory'},
            "rakudo-$config_info->{'Rakudo version'}"
        );
    }
    elsif ($config_info->{'Rakudo version'} eq 'bleeding') {
        $rakudo_build_dir = $config_info->{'Rakudo build directory'};
    }
    else {
        die "Rakudo version was neither 'bleeding' nor a number like '2010.02'";
    }
    if ( ! -f "$rakudo_build_dir/perl6" ) {
        print "Building Rakudo in $rakudo_build_dir...";
        my $cwd = Cwd->getcwd();
        chdir $rakudo_build_dir or die "cannot chdir";
        my $parrot_config = File::Spec->catfile(
            $config_info->{'Parrot install directory'},
            'bin',
            'parrot_config'
        );
        my @rakudo_options = (
            "--parrot-config=$parrot_config"
        );
        my $command = "$^X Configure.pl @rakudo_options";
        print "command = $command\n";
        system( $command );
        $command = "make install";
        system( $command );
        print "\nBuilding Rakudo done\n";
        chdir $cwd;

=pod

        my $flags = '--gen-parrot';
        my $command
            = "(cd $rakudo_build_dir && perl Configure.pl $flags "
              . '&& make install)'
              . ' 2>&1 | ./dotty-progress "Building Perl 6" 3579';
        if ( system($command) != 0 ) {
            print "[ FAIL ]\n";
            if ( system("grep memory make.log $silently") == 0 ) {
                die "Not enough memory to build Perl 6.\n";
            }
            die "Couldn't build Perl 6: $?";
        }
        -f "$rakudo_build_dir/perl6"
            or die "[ FAIL ]\nCouldn't build Perl 6.\n";
        unlink('make.log');
        print "[  ok  ]\n";

=cut

    }
}

#-------------------------- make_pir_modules ---------------------------
sub make_pir_modules {
    # Copy the modules of proto itself from the local lib directory to
    # ~/.perl6/lib, and then compile to .pir format.
    # TODO: multiple versions of the Ecosystem and Installer modules
    my ($perl6exe, $perl6libdir) = @_;
    my $displayed_building = 0;
    # Be sure the destination directory exists
    unless ( -d $perl6libdir ) {
        warn "making $perl6libdir";
        system( "perl -MExtUtils::Command -e mkdir $perl6libdir" );
    }
    # Precompile these modules to PIR
    for my $name ( 'Ecosystem', 'Installer' ) {
        # If it is newer or has not been copied, copy "$name.pm" from
        # "lib/" to "$perl6libdir/".
        # -M is script start time minus file modification time, in days.
        if ( ! -f "$perl6libdir/$name.pm" || -M "lib/$name.pm" < -M "$perl6libdir/$name.pm" ) {
            unless ( $displayed_building ) {
                print "Building proto..."; $displayed_building = 1;
            }
            # warn "copying $name to $perl6libdir\n";
            system( "perl -MExtUtils::Command -e cp lib/$name.pm $perl6libdir" );
            # Maybe the main proto script (written in Perl 5) would have
            # been able to load the ExtUtils::Command module anyway, and
            # could have done the mkdir and cp commands internally...
            # Such usage is not documented.
        }
        if ( ! -f "$perl6libdir/$name.pir" || -M "$perl6libdir/$name.pm" < -M "$perl6libdir/$name.pir" || -M $perl6 < -M "$perl6libdir/$name.pir" ) {
            unless ( $displayed_building ) {
                print "Building proto..."; $displayed_building = 1;
            }
            # warn "compiling $perl6libdir/$name.pir\n";
            system( "$perl6 --target=pir --output=$perl6libdir/$name.pir $perl6libdir/$name.pm" );
        }
    }
    if ( $displayed_building ) {
        print "done\n";
    }
}

#--------------------------- legacy_projects ---------------------------
sub legacy_projects {
    my ( $config_info ) = @_;
    my @legacy_projects;
    my $project_dir = $config_info->{'Proto projects directory'};
    open PROJECTS_LIST, '<', 'projects.list' or die "cannot open projects list";
    while ( defined( my $line = <PROJECTS_LIST> ) ) {
        if ( $line =~ m/ ^ (\S+) : $ /x ) {
            my $project = $1;
            if ( -d "$project_dir/$project" and $project ne 'proto' ) {
                push @legacy_projects, $project;
            }
        }
    }
    close PROJECTS_LIST;
    return @legacy_projects;
}

#--------------------- create_default_config_file ----------------------
sub create_default_config_file {
    my ($proto_config_file) = @_;
    # Derive all the other directories and filenames from
    # $proto_config_file (usually ~/.perl6/proto/proto.conf).
    my ($home_vol, $proto_path, $config_file) = File::Spec->splitpath( $proto_config_file );
    my @proto_dirs = File::Spec->splitdir( $proto_path );
    pop @proto_dirs if ( $proto_dirs[$#proto_dirs] eq '' ); # useless
    my @perl6_dirs = @proto_dirs[0 .. $#proto_dirs-1];
    my $perl6_dir = File::Spec->catdir( @perl6_dirs );
    my $perl6_lib_path = File::Spec->catpath( $home_vol, $perl6_dir, 'lib' );
    my $proto_cache_dir = File::Spec->catdir( @proto_dirs );
    my $proto_cache_path = File::Spec->catpath( $home_vol, $proto_cache_dir, 'cache' );
    # create directories if they do not yet exist
    for my $path ( $perl6_lib_path, $proto_cache_path ) {
        File::Path->make_path($path) unless ( -d $path );
    }
    my $rakudo_build_dir = File::Spec->catpath( $home_vol, $perl6_dir, 'rakudo' );
    my $parrot_build_dir = File::Spec->catpath( $home_vol, $perl6_dir, 'parrot' );
    my $parrot_install_dir = File::Spec->catpath( $home_vol, $perl6_dir, 'parrot_install' );
    my @proto_cache_dirs = ( @proto_dirs, 'cache' );
    my $projects_cache_dir = File::Spec->catpath( $home_vol, File::Spec->catdir(@proto_dirs), 'cache' );

    my $perl6exe;
    if ( exists( $ENV{PERL6EXE} ) ) { # if you know what you're doing
        $perl6exe = $ENV{PERL6EXE};
    }
    else { # default: install rakudo in ~/.perl6/parrot_install/bin
        my $parrot_install_bin_dir = File::Spec->catdir( @perl6_dirs, 'parrot_install', 'bin' );
        $perl6exe = File::Spec->catpath( $home_vol, $parrot_install_bin_dir, 'perl6' );
    }

    my $config_info = {
        'proto.conf version'       => '2010-03-28',
        'Rakudo version'           => 'bleeding',
        'Parrot version'           => 'trunk',
        'Proto projects cache'     => $projects_cache_dir,
        'Rakudo build directory'   => $rakudo_build_dir,
        'Parrot build directory'   => $parrot_build_dir,
        'Parrot install directory' => $parrot_install_dir,
        'Perl 6 executable'        => $perl6exe,
        'Perl 6 library'           => $perl6_lib_path,
        'Test when building'       => 'no',
        'Test failure policy'      => 'die',
        'Perl 6 project developer' => 'no',
    };
    my  $commentinfo = {
        '/' => [ 'proto.conf -- created by proto',
                 'The file consists of a number of settings written as',
                 'key/value pairs. You are welcome -- encouraged, even -- to',
                 'edit the file manually, but please stick to a list of',
                 'key/value pairs.' ],
        'config.proto version'
            => [ 'config.proto version -- the version number of this file.',
                 'proto uses it to determine whether the file needs to be',
                 'upgraded to a newer version. The value should never need',
                 'to be edited manually.' ],
        'Proto projects cache'
            => [ 'Proto projects cache -- the base directory in which each project',
                 'gets its own download directory' ],
        'Rakudo build directory'
            => [ 'Rakudo build directory -- Rakudo source is compiled here. ' ],
        'Rakudo version'
            => [ "Rakudo version -- either 'bleeding' or a number such as '2010.02'" ],
        'Parrot build directory'
            => [ 'Parrot build directory -- Parrot source is compiled here. ' ],
        'Parrot version'
            => [ "Parrot version -- either 'trunk' or a number such as '2.2.0'" ],
        'Perl 6 executable'
            => [ 'Perl 6 executable -- how to run perl6. ' ],
        'Perl 6 library'
            => [ 'Perl 6 library -- the path to a directory, which will be created',
                 'if it does not exist, which will contain the projects installed',
                 'by proto. If you set this to a different path after projects',
                 'have already been installed, be aware that the old projects',
                 'will have to be moved along if proto is to find them' ],
        # TODO: Implement downloading of specific releases.
        'Rakudo revision'
            => [ 'Rakudo revision -- the revision of Rakudo Perl 6 to',
                 'download, if no such revision was found in $RAKUDO_DIR or',
                 'other likely locations at startup. Allowed values are',
                 '"bleeding", "release", and a hexadecimal integer of length',
                 'up to 40. The value "bleeding" means to download the latest',
                 'Rakudo Perl 6 revision from github, whereas "release" means',
                 'to download the latest release as a tarball.' ],
        'Test when building'
            => [ 'Test when building -- when building projects that were just',
                 'downloaded or updated, whether to also run the test suites',
                 'of those projects. This option only controls whether the',
                 'tests are actually run; the "Test failure policy"',
                 'determines whether or not to halt the build process on',
                 'a failing test suite. Values other than "yes" are treated',
                 'as "no".' ],
        'Test failure policy'
            => [ 'Test failure policy -- what to do when tests fail in the',
                 'test suites of projects that are being installed. Note that',
                 'this option has no effect unless the option "Test when',
                 'building" has been set to "yes". The value "die" of this',
                 'option means that the build process halts whenever a test',
                 'suite fails. Other values are treated as "keep going".' ],
        'Perl 6 project developer'
            => [ 'Perl 6 project developer -- when set, this option makes',
                 'proto try to download read-write versions of project',
                 'repositories, from which project development can be',
                 'carried out. If such a download fails, proto falls back to',
                 'downloading the project the usual way.' ],
    };
    save_config_file($proto_config_file, $config_info, $commentinfo )
        or die "Couldn't create $proto_config_file: $!\n";
}

#---------------------- create_default_state_file ----------------------
sub create_default_state_file {
    my ($file_name, @project_names ) = @_;
    my $project_dir = $config_info->{'Proto projects directory'};
    open PROJECTS_STATE, ">", $file_name or die "cannot create $file_name: $!";
    for my $project_name (@project_names) {
        my $path = "$project_dir/$project_name";
        print PROJECTS_STATE join "\n",
            "$project_name:",
            '    state: legacy',
            "    old-location: $path",
            '',
            '';
    }
    close PROJECTS_STATE;
}

#-------------------------- load_config_file ---------------------------
sub load_config_file {
    my ( $filename ) = @_;
    my $settings = {};
    my $comments = {};
    my @collected_comments = ();
    open my $YAML_FILE, '<', $filename
        or die "cannot open $filename for read: $!";
    my $doc_sep_line = qr/^---/;
    my $comment_line = qr/\#(.*)$/;
    my $setting_line = qr/(.*):\s+(.*)/;
    while ( my $line = <$YAML_FILE> ) {
        chomp $line;
        if ( $line =~ $doc_sep_line ) {
            $comments->{'/'} = [ @collected_comments ];
            @collected_comments = ();
        }
        elsif ( $line =~ $comment_line ) {
            push @collected_comments, $1;
        }
        elsif ( $line =~ $setting_line ) {
            $settings->{$1} = $2;
            $comments->{$1} = [ @collected_comments ];
            @collected_comments = ();
        }
    }
    close $YAML_FILE;
    return wantarray ? ( $settings, $comments ) : $settings;
}

#-------------------------- save_config_file ---------------------------
sub save_config_file {
    my ( $filename, $settings, $comments ) = @_;
    if ( not defined $comments ) { $comments = { }; }
    open my $YAML_FILE, '>', $filename
        or die "cannot open $filename for write: $!";
    my $main_comments = $comments->{'/'};
    if ( defined $main_comments ) {
        for my $comment ( @$main_comments ) {
            print {$YAML_FILE} "# $comment\n";
        }
    }
    print {$YAML_FILE} "--- \n";
    for my $settingname ( sort keys %$settings ) {
        print {$YAML_FILE} "\n";
        my $setting_comments = $comments->{$settingname};
        if ( defined $setting_comments ) {
            for my $comment ( @$setting_comments ) {
                print {$YAML_FILE} "# $comment\n";
            }
        }
        print {$YAML_FILE} "$settingname: ", ${$settings}{$settingname}, "\n";
    }
    close $YAML_FILE;
}

__DATA__

=pod

=head1 NAME

proto - download and install Parrot, Rakudo, and Perl 6 projects

=head1 OVERVIEW

The C<proto> command is a Perl 5 script that installs Rakudo Perl 6 and
Parrot if they are not already installed. It then hands over to the
Perl 6 C<Installer> script to download, test and install your choice of
Perl 6 projects.

The C<Installer> script

=head1 ENVIRONMENT

PERL6EXE - if exported by the shell, specifies where to look for an
installed Perl 6 executable. Not required if your shell executes 'perl6'
anyway.  The setting is saved as 'Perl 6 executable' in config.proto.
It is configured automatically if you let proto install Rakudo (and
Parrot).  For example, to use perl6.pbc instead of the fakecutable use
something like:

    PERL6EXE=/my/parrot_install/bin/parrot \
        /my/parrot_install/lib/<version>/languages/perl6/perl6.pbc \
        ./proto

=head1 ROADMAP

The current proto roadmap responds to the Rakudo * initiative, its
nql-rx refactor and the related S11 Modules proposal
(github.com/rakudo/rakudo/blob/master/docs/S11-Modules-proposal.pod).

Rakudo * release needs only a subset of these proto roadmap goals.
The rest are desirable enhancements.

The previous proto roadmap was called 'installed-modules', and is still
included below for planning reference, but not necessarily to guide
implementation.

1.  Fixing.  Make proto work with the latest master Rakudo, formerly
    known as the 'ng' branch.  There were a few regressions switching
    over.  Problems are being handled by working around in proto,
    commenting the fixes as WORKAROUND, and reporting them in #perl6.
    This approach leaves a TODO item here, to find WORKAROUND comments,
    handle them better, or notify http://rt.perl.org/rt3 by mailing
    rakudobug@perl.org.

2.  Directories.  The user may override anything, but default to all
    subdirectories of ~/.perl6, as follows:

        lib             root of the Perl 6 module hierarchy
        parrot          main Parrot download/build directory
            parrot-x.y.z  source directory of a specific Parrot version
        parrot_install  parrot virtual machine runtime base
            bin         for parrot executables, eg perl6.pbc
        proto           keep proto.conf and projects.state here
            cache       where projects are downloaded and tested
        rakudo          Rakudo download/build directory

    By making the parrot, parrot_install and rakudo directories not nest
    in each other, there is more flexibility for customization.  If a
    user prefers the directory nesting done by Rakudo's --gen-parrot
    option, proto can work with that too.

    To be Windows compatible, proto will use Perl 5 modules such as
    File::Spec and File::Path to handle all directory and file names,
    and LWP::UserAgent and Archive::Extract to process the archive files.

3.  Modules.  Also put project.state and config.proto in the
    ~/.perl6/lib directory.  Modules installed by proto keep working
    even if proto is removed.  Thus proto can be replaced and phased out.

4.  Runtime.  Build in ~/.perl6/parrot and ~/.perl6/rakudo, install the
    binaries in ~/.perl6/parrot_install and then remove the build dirs.
    Let the user edit config.proto to override the directory paths and
    turn off source tree removal.  Make it easy to install multiple
    implementations side by side, for example Rakudo on Parrot, Rakudo
    on Common Language Infrastructure, Pugs, Mildew etc.  Treat them as
    special projects that can be installed, updated or removed.

5.  Updating.  Re-install proto, Rakudo and Parrot from newer release
    downloads if the user chooses, and if the date suggests they should
    be available.

6.  Versioning.  Implement the librarian functions of the S11 Modules
    proposal.  Details to be worked out.

7.  Cheese speleology: remember http://use.perl.org/~masak/journal/39583
    and implement it.  Easier said than done, but now is the very best
    time to start.  Details to be worked out.

=head1 TODO

1.  The new Rakudo master is not backwards compatible with the alpha
    branch, so rip out the old legacy project support.

2.  For Windows compatibility, change all hard coded mkdir and cp
    commands to use the Perl 5's L<ExtUtils::Command> with C<-e mkpath>
    and C<-e cp> instead.

3.  The install command will need to be able specify :auth<> and :ver<>
    and look them up in projects.list.

4.  Advise the user to either 1) point the system path to
    installed_modules/bin, or 2) add a symbolic link in a system path
    directory to the perl6 fakecutable.

5.  Also put the proto executable
    in the bin directory and enable it to be run independent of the
    current working directory.

99. Reduce all WORKAROUND comments to simple cases in rakudobug reports
    and replace the comments with TODO items linked to RT numbers.

=head1 Rakudo/alpha old TODO list (partly deprecated)

The installed-modules branch plans to improve proto by doing the following:

1.  Place all installed Perl 6 modules (.pm and .pir files) into one
    folder hierarchy. Rakudo now preloads @*INC with $HOME/.perl6lib,
    followed by <parrot_install>/lib/<version/languages/perl6/lib, the
    directories in PERL6LIB, and lastly '.' (the current directory).
    Add a "Perl 6 library" setting to config.proto, with $HOME/.perl6/lib
    as default value.
    [DONE]

2.  Keep a separate cache directory per project for all processing prior
    to installation. Allow the cache directory to be cleaned or removed
    without affecting the installed module.
    Add a "Proto cache directory" to config.proto with a default value
    of <proto_base>/cache.
    [DONE]

3.  Add a projects.state file to register installed projects.
    The format of projects.state is similar to projects.list, currently
    with a C<state> field whose value may be 'legacy', 'built', 'tested'
    (meaning passed *all* tests in the cache directory) or 'installed'.
    Route all access to projects.state information via the Ecosystem class.
    [DONE]

4.  Rename the existing "fetch" submethod to "download", "install" ->
    "fetch", "update" -> "refresh" and "uninstall" -> "clean".
    Rename Ecosystem::is-installed() to Ecosystem::is_fetched().
    [DONE]

5.  Factor out the code common in the existing "install" and "update"
    methods, or unify them and add a new/existing flag. Either way, stop
    the repetition because we need to edit this part significantly.
    [DONE]

6.  Replace the 'Parrot directory' and 'Rakudo directory' settings with
    'Perl 6 executable' in config.proto.
    [DONE]

7.  Make install_perl6 implement L<http://www.rakudo.org/how-to-get-rakudo>,
    including the new 'make install' step.
    [DONE]

8.  Use the shiny new %*ENV for passing environment variables to child
    processes.
    [DONE]

9.  Add a new "install" step to the end of the existing "fetch,
    configure, build, test" workflow, to copy module files to the
    "Perl 6 library" tree.
    To install modules into the global library tree, first look for an
    an 'install' target in the Makefile, run it if found.
    If there is no 'install', check that all the files in lib/ can be
    copied without clobbering, then either proceed to copy or abort.
    [DONE]

10. Drop the migration plan for existing installations: laziness++ ;)
    Just warn the user as long as the old config.proto has not been
    upgraded, and record as "state: legacy: /path" in projects.state.
    This must be overwritten if the user later re-installs the project.
    [DONE]

11. Add a showstate command to report on the state of all fetched or
    installed projects.
    [DONE]

12. Handle "uninstall" by Makefile or by listing all the names in
    $project/lib and deleting each same named file in "Perl 6 library".
    Also remove the project name from projects.installed and delete the
    project cache directory. Think "realclean".
    We could keep the cache, but a "rm -rf" and a new fetch is cleaner.
    [PARTDONE]

13. Add a new "update" command. To be fail-safe, cache the project's
    downloaded cache (yes, cache the cache) by copying everything into
    another directory called cache/$project.temp. Refresh the normal
    cache. Determine whether there are any differences and back out
    politely if nothing changed. Build and test the updated project in
    the refreshed cache directory. If it passes, rename the cache
    directory to cache/$project.new and rename the cache/$project.temp
    to just cache/$project, and uninstall the old version of the project.
    Discard the old project cache and rename the .new back. Install.

14. Ensure robustness of the workflow, so that an error in fetching,
    building or testing any dependency, stops the dependent module
    being installed. Refactor the existing code to do this very
    concisely in the top level methods.

15. Validate @*INC by exiting with a friendly explanation if @*INC does
    not contain the 'Perl 6 library' directory. List the possible fixes:
    edit config.proto (set Perl 6 library), or any one of
    ~/.bash_profile, ~/.bash_login, or ~/.profile (set PERL6LIB).
    Make this behaviour optional with a 'Validate Perl 6 library' option
    in config.proto.

16. Update create-new-project to support install, update and uninstall
    in its Makefile. Document it as a guideline for module developers.
    This facility is new to proto, so it is also new to all projects.
    The 'make' utility will need to know where to find 'Perl 6 library',
    so do this: %*ENV<PERL6LIB> = %!config-info{'Perl 6 library'}.

17. When loading projects.list also load a projects.local if it exists.
    The projects.local file allows individual projects to be handled by
    proto without causing git conflicts on projects.list.

18. ...keep planning and doing...

19. Build a test suite for proto itself, with the possibility of partial
    testing offline. With acceptable test coverage, proto will be safer
    to develop and use until other infrastructure tools usurp it.
    Use a test version of config.proto that points to test directories,
    so that the main installation is not affected.
    For even better testing, consider testing proto inside a chroot jail
    to prevent bugs from damaging things. Building the jail may be a bit
    complicated though, think it through first.
    [OPTIONAL]

20. Improve the usage message and provide help per command.

21. Make 'test' (of a project) show details of failures. Also add a
    'test all' suitable for "Cheese speleology".
    [OPTIONAL]

22. Refactor into MVC form. Details to be determined. Some ideas:
    Model is currently only Ecosystem (metadata). It should also include
    handling files and directories in the proto/cache/ and the
    'Perl 6 library' tree, perhaps within a separate module.
    View is the part of Installer.pm that deals with lists of projects,
    commands and other user I/O.
    Controller is the part of Installer.pm that er, controls flow, but
    it should leave the actual updating of projects, files and state to
    Model.
    [OPTIONAL]

23. Emulate Debian's 'popularity-contest' for package usage statistics,
    based on anonymous submission via smtp or http.
    [OPTIONAL]

=cut
