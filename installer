#!perl6
use v6;

my %project_info = read-module-list('modules.list');

my $PWD = %*ENV<PWD>; # from proto script

given @*ARGS.shift {
    when undef       { exit; }
    when 'install'   { install(  @*ARGS) }
    when 'update'    { update(   @*ARGS) }
    when 'uninstall' { uninstall(@*ARGS) }
    when 'test'      { test(     @*ARGS) }
    when 'showdeps'  { showdeps( @*ARGS) }
    default          { say "Unrecognized subcommand '$_'. See the README." }
}

sub install(*@projects) {
    my @projects-to-install;
    my $missing_projects = False;
    for @projects -> $project {
        if !%project_info.exists($project) {
            say "Project not found: '$project'";
            $missing_projects = True;
        }
        elsif "projects/$project" ~~ :d {
            say "Won't install $project: already installed.";
        }
        else {
            @projects-to-install.push($project);
        }
    }
    if $missing_projects {
        say 'Try updating proto to get the latest list of projects.';
        exit(1);
    }
    if !@projects-to-install {
        say 'Nothing to install.';
        exit(1);
    }
    fetch-and-build-projects-and-their-deps(@projects-to-install.uniq);
}

sub update(*@projects) {
    my @projects-to-update;
    my $missing_projects = False;
    for @projects -> $project {
        if !%project_info.exists($project) {
            say "No such project: '$project'";
            $missing_projects = True;
        }
        elsif "projects/$project" !~~ :d {
            say "Cannot update $project: not installed.";
        }
        else {
            @projects-to-update.push($project);
        }
    }
    if $missing_projects {
        exit(1);
    }
    if !@projects-to-update {
        # TODO: This should probably mean 'update everything', for some value
        #       of 'everything'. Either we'll require an 'all' pseudopackage
        #       or we'll consider no package at all synonymous to 'all'.
        say 'Nothing to update.';
        exit(1);
    }
    fetch-and-build-projects-and-their-deps(@projects-to-update.uniq);
}

sub uninstall(*@projects) {
    not_implemented('uninstall');
}

sub test(*@projects) {
    unless @projects {
        say 'You have to specify what you want to test.';
        # TODO: Maybe just test everything installed?
        exit 1;
    }
    my $can_continue = True;
    for @projects -> $project {
        if !%project_info.exists($project) {
            say "Project not found: '$project'";
            $can_continue = False;
        }
        # TODO: Also need to check that projects are actually installed.
    }
    if !$can_continue {
        say "Aborting...";
        exit(1);
    }
    for @projects -> $project {
        my %info = %project_info{$project};
        # RAKUDO: Doesn't support any other way to change the current working
        #         directory. Improvising.
        my $project_dir = %info.exists('main_subdir')
                          ?? "projects/$project/{%info<main_subdir>}"
                          !! "projects/$project";
        my $in_dir = "cd $project_dir";
        # RAKUDO: Can't really figure out how to set environment variables
        #         so they're visible by later commands. Doing like this
        #         instead.
        my $p6l = "env PERL6LIB=$PWD/projects/$project_dir/lib";
        print "Building $project... ";
        run( "$in_dir; $p6l make test" );
    }

}

# TODO: This sub should probably recursively show dependencies, and in such
#       a way that a dependency found twice by different routes is only
#       mentioned the second time -- its dependencies are not shown.
sub showdeps(*@projects) {
    unless @projects {
        say "You have to specify which projects' dependencies to show.";
        exit 1;
    }
    for @projects -> $project {
        if "projects/$project" !~~ :d {
            say "$project is not installed.";
            next;
        }
        my @deps = get_deps( "projects/$project/deps.proto" );
        if !@deps {
            say "$project has no dependencies.";
            next;
        }
        say $project, ':';
        for @deps -> $dep {
            say '  ', $dep;
        }
    }
}

sub fetch-and-build-projects-and-their-deps(@projects) {
    # TODO: Though the below traversal works, it seems much cooler to do builds
    #       as soon as possible. Right now, in a dep tree looking like this:
    #       :A[ :B[ 'C', 'D' ], 'E' ], we download A-B-E-C-D and then build
    #       D-C-E-B-A. Though this works, one could conceive of a download
    #       preorder A-B-C-D-E and a build postorder C-D-B-E-A.
    #       Those could even be interspersed build-soonest, making it
    #       dA-dB-dC-bC-bD-bB-dE-bE-bA.
    my %seen-dep;
    for @projects -> $top-project {
        my @fetch-queue = $top-project;
        my @build-stack = $top-project;

        while @fetch-queue {
            my $project = @fetch-queue.shift;

            fetch($project);
            my $target_dir = "projects/$project";
            for get_deps( "$target_dir/deps.proto" ) -> $dep {
                next if %seen-dep<<$dep>>++;
                @fetch-queue.push($dep);
                @build-stack.unshift($dep);
            }
        }

        for @build-stack -> $project {
            do_build($project);
        }
    }
}

sub fetch( Str $project ) {
    if not defined %project_info{$project} {
        say "proto installer does not know about project '$project'";
        say 'Try updating proto to get the latest list of projects.';
        # TODO: It seems we can do better than this. A failed download does
        #       not invalidate a whole installation process, only the
        #       dependency tree in which it is a part. Passing information
        #       upwards with exceptions would provide excellent error
        #       diagnostics (either it failed because it wasn't found, or
        #       because dependencies couldn't be installed).
        exit 1;
    }
    my $target_dir = "projects/$project";
    my %info       = %project_info{$project};
    my $silently   = '>/dev/null 2>&1';
    if $target_dir ~~ :d {
        print "Updating $project...";
        my $indir = "cd $target_dir";
        my $command = do given %info<home> {
            when 'github'     { 'git pull' }
            when 'googlecode' { 'svn up' }
        };
        run( "$indir; $command $silently" );
        say 'updated';
    }
    else {
        print "Downloading $project...";
        my $name       = %info<name> // $project;
        my $command = do given %info<home> {
            when 'github' {
                sprintf 'git clone git://github.com/%s/%s.git %s',
                        %info<owner>,
                        $name,
                        $target_dir;
            }
            when 'googlecode' {
                "svn co https://$name.googlecode.com/svn/trunk $target_dir";
            }
            default { die "Unknown home type {%info<home>}"; }
        };
        run( "$command $silently" );
        say 'downloaded';
    }
}

sub do_build( Str $projectName ) {
    print "Building $projectName...";
    # RAKUDO: Doesn't support any other way to change the current working
    #         directory. Improvising.
    my %info       = %project_info{$projectName};
    my $target_dir  = "projects/$projectName";
    my $project_dir = $target_dir;
    if defined %info<main_subdir> { $project_dir = %info<main_subdir>; }
    my $in_dir = "cd $project_dir";
    # RAKUDO: Can't really figure out how to set environment variables
    #         so they're visible by later commands. Doing like this
    #         instead.
    my $p6lib
        = 'env PERL6LIB='
          ~ join ':', map { "$PWD/projects/$_/lib" },
                          $projectName, get_deps_deeply( $projectName );
    # XXX: Need to have error handling here, and not continue if things go
    #      haywire with the build. However, a project may not have a
    #      Makefile.PL, and this needs to be considered a successful [sic]
    #      outcome.
    run( "$in_dir; yes '' | $p6lib perl Makefile.PL > make.log 2>\&1" );
    run( "$in_dir; $p6lib make >> make.log 2>\&1" );
    say 'built';
#   unlink( "$project_dir/make.log" );
}

sub not_implemented($subcommand) {
    warn "The '$subcommand' subcommand is not implemented yet.";
}

sub get_deps($deps-file) {
    return unless $deps-file ~~ :f;
    my &remove-line-ending-comment = { .subst(/ '#' .* $ /, '') };
    my &trim-spaces = { .subst(/ ^ \h+ /, '').subst(/ \h+ $ /, '') };
    return slurp($deps-file)\
             .split("\n")\
             .map({remove-line-ending-comment($^line)})\
             .map({trim-spaces($^line)})\
             .grep({$^keep-all-nonempty-lines});
}

# XXX: Oops, it's inconsistent that this sub takes a project name while
#      get_deps takes a file name. Should fix one of them; and since this one
#      feels weird with a file name, maybe get_deps should take a project
#      name too.
sub get_deps_deeply($project) {
    my $target_dir = "projects/$project";
    # TODO: Make this one find the deps of the deps, and so on. We're off the
    #       hook for now, since there are no known deps of deps.
    return get_deps( "$target_dir/deps.proto" );
}

sub read-module-list(Str $filename) {
    my $fh = open($filename)
        or die "Can't open '$filename': $!";

    my %overall;
    my $current-name;
    my %current;
    for =$fh {
        when / ^ \s* ['#' | $ ] /   { next };
        when / ^ (\S+) \: \s* ['#' | $ ] / {
            if $current-name.defined {
                %overall{$current-name} = %current.clone;
            }
            %current = ();
            $current-name = ~$0;
        }
        when / ^ \s+ (\S+) ':' \s* (\S+) \s* ['#' | $ ] / {
            %current{~$0} = ~$1;
        }
        default { warn "don't know how to parse the line «$_», ignoring it" };
    }
    if %current {
        %overall{$current-name} = %current;
    }

    return %overall;
}

# vim: ft=perl6
