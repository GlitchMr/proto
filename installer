#!perl6
use v6;

my %project_info =
    november       => { :home<github>,     :owner<viklund>, },
    html-template  => { :home<github>,     :owner<masak>, },
    druid          => { :home<github>,     :owner<masak>, },
    perl6-examples => { :home<github>,     :owner<eric256> },
    uri            => { :home<github>,     :owner<ihrd> },
    web            => { :home<github>,     :owner<masak> },
    svg            => { :home<github>,     :owner<masak> },
    maya           => { :home<github>,     :owner<ihrd> },
    form           => { :home<github>,     :owner<mattw> },
    rakudo-prelude => { :home<googlecode> }
;

my $PWD = %*ENV<PWD>; # from proto script

given @*ARGS.shift {
    when undef       { exit; }
    when 'install'   { install(  @*ARGS) }
    when 'update'    { update(   @*ARGS) }
    when 'uninstall' { uninstall(@*ARGS) }
    when 'test'      { test(     @*ARGS) }
    when 'showdeps'  { showdeps( @*ARGS) }
    default          { say "Unrecognized subcommand '$_'. See the README." }
}

sub install(*@projects) {
    unless @projects {
        say 'You have to specify what you want to install.';
        exit 1;
    }
    my $can_continue = True;
    for @projects -> $project {
        if !%project_info.exists($project) {
            say "Project not found: '$project'";
            $can_continue = False;
        }
        if is_dir("projects/$project") {
            say "Won't install $project: already installed.";
            $can_continue = False;
        }
    }
    if !$can_continue {
        say 'Try updating proto to get the latest list of projects.';
        say 'Aborting...';
        exit(1);
    }
    fetch-and-build-projects-and-their-deps(@projects);
}

sub update(*@projects) {
    unless @projects {
        # TODO: This should probably mean 'update everything', sore some value
        #       of 'everything'. Either we'll require an 'all' pseudopackage
        #       or we'll consider no package at all synonymous to 'all'.
        say 'You have to specify what you want to install.';
        exit 1;
    }
    my $can_continue = True;
    for @projects -> $project {
        if !%project_info.exists($project) {
            say "No such project: '$project'";
            $can_continue = False;
        }
        if !is_dir("projects/$project") {
            say "Cannot update $project: not installed.";
            $can_continue = False;
        }
    }
    if !$can_continue {
        say 'Aborting...';
        exit(1);
    }
    fetch-and-build-projects-and-their-deps(@projects);
}

sub uninstall(*@projects) {
    not_implemented('uninstall');
}

sub test(*@projects) {
    unless @projects {
        say 'You have to specify what you want to test.';
        # TODO: Maybe just test everything installed?
        exit 1;
    }
    my $can_continue = True;
    for @projects -> $project {
        if !%project_info.exists($project) {
            say "Project not found: '$project'";
            $can_continue = False;
        }
        # TODO: Also need to check that projects are actually installed.
    }
    if !$can_continue {
        say "Aborting...";
        exit(1);
    }
    for @projects -> $project {
        my %info = %project_info{$project};
        # RAKUDO: Doesn't support any other way to change the current working
        #         directory. Improvising.
        my $project_dir = %info.exists('main_subdir')
                          ?? "projects/$project/{%info<main_subdir>}"
                          !! "projects/$project";
        my $in_dir = "cd $project_dir";
        # RAKUDO: Can't really figure out how to set environment variables
        #         so they're visible by later commands. Doing like this
        #         instead.
        my $p6l = "env PERL6LIB=$PWD/projects/$project_dir/lib";
        print "Building $project... ";
        run( "$in_dir; $p6l make test" );
    }

}

# TODO: This sub should probably recursively show dependencies, and in such
#       a way that a dependency found twice by different routes is only
#       mentioned the second time -- its dependencies are not shown.
sub showdeps(*@projects) {
    unless @projects {
        say "You have to specify which projects' dependencies to show.";
        exit 1;
    }
    for @projects -> $project {
        if "projects/$project" !~~ :d {
            say "$project is not installed.";
            next;
        }
        my @deps = get_deps( "projects/$project/deps.proto" );
        if !@deps {
            say "$project has no dependencies.";
            next;
        }
        say $project, ':';
        for @deps -> $dep {
            say '  ', $dep;
        }
    }
}

sub fetch-and-build-projects-and-their-deps(@projects) {
    # TODO: Though the below traversal works, it seems much cooler to do builds
    #       as soon as possible. Right now, in a dep tree looking like this:
    #       :A[ :B[ 'C', 'D' ], 'E' ], we download A-B-E-C-D and then build
    #       D-C-E-B-A. Though this works, one could conceive of a download
    #       preorder A-B-C-D-E and a build postorder C-D-B-E-A.
    #       Those could even be interspersed build-soonest, making it
    #       dA-dB-dC-bC-bD-bB-dE-bE-bA.
    my %seen-dep;
    for @projects -> $top-project {
        my @fetch-queue = $top-project;
        my @build-stack = $top-project;

        while @fetch-queue {
            my $project = @fetch-queue.shift;

            fetch($project);
            my $target_dir = "projects/$project";
            for get_deps( "$target_dir/deps.proto" ) -> $dep {
                next if %seen-dep<<$dep>>++;
                @fetch-queue.push($dep);
                @build-stack.unshift($dep);
            }
        }

        for @build-stack -> $project {
            do_build($project);
        }
    }
}

sub fetch( Str $project ) {
    if not defined %project_info{$project} {
        say "proto installer does not know about project '$project'";
        say 'Try updating proto to get the latest list of projects.';
        # TODO: It seems we can do better than this. A failed download does
        #       not invalidate a whole installation process, only the
        #       dependency tree in which it is a part. Passing information
        #       upwards with exceptions would provide excellent error
        #       diagnostics (either it failed because it wasn't found, or
        #       because dependencies couldn't be installed).
        exit 1;
    }
    my $target_dir = "projects/$project";
    my %info       = %project_info{$project};
    my $silently   = '>/dev/null 2>&1';
    if is_dir( $target_dir ) {
        print "Updating $project...";
        my $indir = "cd $target_dir";
        my $command = do given %info<home> {
            when 'github'     { 'git pull' }
            when 'googlecode' { 'svn up' }
        };
        run( "$indir; $command $silently" );
        say 'updated';
    }
    else {
        print "Downloading $project...";
        my $name       = %info<name> // $project;
        my $command = do given %info<home> {
            when 'github' {
                sprintf 'git clone git://github.com/%s/%s.git %s',
                        %info<owner>,
                        $name,
                        $target_dir;
            }
            when 'googlecode' {
                "svn co https://$name.googlecode.com/svn/trunk $target_dir";
            }
            default { die "Unknown home type {%info<home>}"; }
        };
        run( "$command $silently" );
        say 'downloaded';
    }
}

sub do_build( Str $projectName ) {
    print "Building $projectName...";
    # RAKUDO: Doesn't support any other way to change the current working
    #         directory. Improvising.
    my %info       = %project_info{$projectName};
    my $target_dir  = "projects/$projectName";
    my $project_dir = $target_dir;
    if defined %info<main_subdir> { $project_dir = %info<main_subdir>; }
    my $in_dir = "cd $project_dir";
    # RAKUDO: Can't really figure out how to set environment variables
    #         so they're visible by later commands. Doing like this
    #         instead.
    my $p6lib
        = 'env PERL6LIB='
          ~ join ':', map { "$PWD/projects/$_/lib" },
                          $projectName, get_deps_deeply( $projectName );
    # XXX: Need to have error handling here, and not continue if things go
    #      haywire with the build. However, a project may not have a
    #      Makefile.PL, and this needs to be considered a successful [sic]
    #      outcome.
    run( "$in_dir; yes '' | $p6lib perl Makefile.PL > make.log 2>\&1" );
    run( "$in_dir; $p6lib make >> make.log 2>\&1" );
    say 'built';
#   unlink( "$project_dir/make.log" );
}

sub not_implemented($subcommand) {
    warn "The '$subcommand' subcommand is not implemented yet.";
}

sub get_deps($deps-file) {
    return if !is_file($deps-file);
    my &remove-line-ending-comment = { .subst(/ '#' .* $ /, '') };
    my &trim-spaces = { .subst(/ ^ \h+ /, '').subst(/ \h+ $ /, '') };
    return slurp($deps-file)\
             .split("\n")\
             .map({remove-line-ending-comment($^line)})\
             .map({trim-spaces($^line)})\
             .grep({$^keep-all-nonempty-lines});
}

# XXX: Oops, it's inconsistent that this sub takes a project name while
#      get_deps takes a file name. Should fix one of them; and since this one
#      feels weird with a file name, maybe get_deps should take a project
#      name too.
sub get_deps_deeply($project) {
    my $target_dir = "projects/$project";
    # TODO: Make this one find the deps of the deps, and so on. We're off the
    #       hook for now, since there are no known deps of deps.
    return get_deps( "$target_dir/deps.proto" );
}

# RAKUDO: Temporary workaround while we await :f
sub is_file( Str $filename ) {
    my $tempfile = "/tmp/installer_is_file.txt";
    my $command = "ls -ld $filename >$tempfile 2>/dev/null";
    run( $command );
    my $ls_result = slurp( $tempfile );
    unlink $tempfile;
    my Bool $status = ? ($ls_result ~~ / ^ '-' /);
    return $status;
}

# RAKUDO: Temporary workaround while we await :d
sub is_dir( Str $dirname ) {
    my $tempfile = "/tmp/installer_is_dir.txt";
    my $command = "ls -ld $dirname >$tempfile 2>/dev/null";
    run( $command );
    my $ls_result = slurp( $tempfile );
    unlink $tempfile;
    my Bool $status = ? ($ls_result ~~ / ^ 'd' /);
    return $status;
}
